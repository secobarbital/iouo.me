{
  "name": "ampersand-router",
  "description": "Clientside router with fallbacks for browsers that don't support pushState. Mostly lifted from Backbone.js.",
  "version": "1.0.2",
  "author": {
    "name": "Henrik Joreteg",
    "email": "henrik@andyet.net"
  },
  "bugs": {
    "url": "https://github.com/ampersandjs/ampersand-router/issues"
  },
  "dependencies": {
    "ampersand-class-extend": "^1.0.0",
    "backbone-events-standalone": "0.2.2",
    "underscore": "^1.6.0"
  },
  "devDependencies": {
    "browserify": "^4.1.10",
    "precommit-hook": "~0.3.10",
    "run-browser": "^1.3.1",
    "tap-spec": "^0.2.0",
    "tape": "^2.13.2",
    "tape-run": "^0.1.1",
    "underscore": "1.x.x"
  },
  "homepage": "https://github.com/ampersandjs/ampersand-router",
  "keywords": [
    "clientside",
    "router",
    "history"
  ],
  "license": "MIT",
  "main": "ampersand-router.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/ampersandjs/ampersand-router"
  },
  "scripts": {
    "start": "run-browser test/index.js"
  },
  "readme": "# ampersand-router\n\nClientside router with fallbacks for browsers that don't support pushState. Mostly lifted from [Backbone.js](http://backbonejs.org/#Router).\n\nAmpersand-router also adds a `redirectTo` method which is handy for doing \"internal\" redirects without breaking backbutton functionality in the browser.\n\n<!-- starthide -->\nPart of the [Ampersand.js toolkit](http://ampersandjs.com) for building clientside applications.\n<!-- endhide -->\n\n## install\n\n```\nnpm install ampersand-router\n```\n\n<!-- starthide -->\n## example\n\n```javascript\nvar Router = require('ampersand-router');\n\n\nmodule.exports = Router.extend({\n    routes: {\n        '': 'home',\n        'users/:id': 'userDetail',\n        'info': 'info'\n    },\n\n    // ------- ROUTE HANDLERS ---------\n    home: function () {\n        this.trigger('newPage', new HomePage());\n    },\n\n    // redirect example\n    userDetail: function (id) {\n        var user = app.users.get(id);\n        if (user) {\n            this.trigger('newPage', new HomePage());\n        } else {\n            this.redirectTo('users');\n        }\n    }\n\n    ...\n});\n```\n<!-- endhide -->\n\n## API Reference\n\n### extend `AmpersandRouter.extend(properties)`\n\nGet started by creating a custom router class. Define actions that are triggered when certain URL fragments are matched, and provide a [routes](#ampersand-router-routes) hash that pairs routes to actions. Note that you'll want to avoid using a leading slash in your route definitions:\n\n```javascript\nvar AppRouter = AmpersandRouter.extend({\n\n  routes: {\n    \"help\":                 \"help\",    // #help\n    \"search/:query\":        \"search\",  // #search/kiwis\n    \"search/:query/p:page\": \"search\"   // #search/kiwis/p7\n  },\n\n  help: function() {\n    //...\n  },\n\n  search: function(query, page) {\n    //...\n  }\n\n});\n```\n\n### routers `router.routes`\n\nThe routes hash maps URLs with parameters to functions on your router (or just direct function definitions, if you prefer), similar to the [View](#ampersand-view)'s [events hash](#ampersand-view-events). Routes can contain parameter parts, `:param`, which match a single URL component between slashes; and splat parts `*splat`, which can match any number of URL components. Part of a route can be made optional by surrounding it in parentheses `(/:optional)`.\n\nFor example, a route of `\"search/:query/p:page\"` will match a fragment of `#search/obama/p2`, passing `\"obama\"` and `\"2\"` to the action.\n\nA route of `\"file/*path\"` will match `#file/nested/folder/file.txt`, passing `\"nested/folder/file.txt\"` to the action.\n\nA route of `\"docs/:section(/:subsection)\"` will match #docs/faq and #docs/faq/installing, passing `\"faq\"` to the action in the first case, and passing `\"faq\"` and `\"installing\"` to the action in the second.\n\nTrailing slashes are treated as part of the URL, and (correctly) treated as a unique route when accessed. `docs` and `docs/` will fire different callbacks. If you can't avoid generating both types of URLs, you can define a `\"docs(/)\"` matcher to capture both cases.\n\nWhen the visitor presses the back button, or enters a URL, and a particular route is matched, the name of the action will be fired as an event, so that other objects can listen to the router, and be notified. In the following example, visiting `#help/uploading` will fire a `route:help` event from the router.\n\n```javascript\nroutes: {\n  \"help/:page\":         \"help\",\n  \"download/*path\":     \"download\",\n  \"folder/:name\":       \"openFolder\",\n  \"folder/:name-:mode\": \"openFolder\"\n}\n\nrouter.on(\"route:help\", function(page) {\n  ...\n});\n```\n\n### constructor / initialize `new Router([options])`\n\nWhen creating a new router, you may pass its routes hash directly as an option, if you choose. All options will also be passed to your `initialize` function, if defined.\n\n### route `router.route(route, name, [callback])`\n\nManually create a route for the router, The `route` argument may be a routing string or regular expression. Each matching capture from the route or regular expression will be passed as an argument to the callback. The `name` argument will be triggered as a `\"route:name\"` event whenever the route is matched. If the `callback` argument is omitted `router[name]` will be used instead. Routes added later may override previously declared routes.\n\n```javascript\ninitialize: function(options) {\n\n  // Matches #page/10, passing \"10\"\n  this.route(\"page/:number\", \"page\", function(number){ ... });\n\n  // Matches /117-a/b/c/open, passing \"117-a/b/c\" to this.open\n  this.route(/^(.*?)\\/open$/, \"open\");\n\n},\n\nopen: function(id) { ... }\n```\n\n### navigate `router.navigate(fragment, [options])`\n\nWhenever you reach a point in your application that you'd like to save as a URL, call *navigate* in order to update the URL. If you wish to also call the route function, set the `trigger` option to `true`. To update the URL without creating an entry in the browser's history, set the `replace` option to `true`.\n\n```javascript\nopenPage: function(pageNumber) {\n  this.document.pages.at(pageNumber).open();\n  this.navigate(\"page/\" + pageNumber);\n}\n\n// Or ...\n\napp.navigate(\"help/troubleshooting\", {trigger: true});\n\n// Or ...\n\napp.navigate(\"help/troubleshooting\", {trigger: true, replace: true});\n```\n\n### redirectTo `router.redirectTo(fragment)`\n\nSometimes you want to be able to redirect to a different route in your application without adding an entry in the browser's history. RedirectTo is just a shorthand for calling [navigate](#ampersand-router-navigate) with both `trigger` and `replace` set to `true`.\n\n```javascript\nvar AppRouter = AmpersandRouter.extend({\n    routes: {\n        'login': 'login',\n        'dashboard': 'dashboard'\n    },\n\n    dashboard: function () {\n        if (!app.me.loggedIn) return redirectTo('login');\n\n        // show dashboard page...\n    }\n});\n```\n\n### execute `router.execute(callback, args)`\n\nThis method is called internally within the router, whenever a route matches and its corresponding callback is about to be executed. Override it to perform custom parsing or wrapping of your routes, for example, to parse query strings before handing them to your route callback, like so:\n\n```javascript\nvar Router = AmpersandRouter.extend({\n  execute: function(callback, args) {\n    args.push(parseQueryString(args.pop()));\n    if (callback) callback.apply(this, args);\n  }\n});\n```\n\n### history.start `router.history.start([options])`\n\nAmpersandRouter automatically requires and instantiates a single ampersand-history object. AmpersandHistory serves as a global router (per frame) to handle hashchange events or pushState, match the appropriate route, and trigger callbacks. You shouldn't ever have to create one of these yourself since ampersand-router already contains one.\n\nWhen all of your Routers have been created, and all of the routes are set up properly, call `router.history.start()` on one of your routers to begin monitoring hashchange events, and dispatching routes. Subsequent calls to `history.start()` will throw an error, and `router.history.started` is a boolean value indicating whether it has already been called.\n\nSupported options:\n\n* **pushState** {Boolean} - To indicate that you'd like to use HTML5 pushState support in your application, use `router.history.start({pushState: true})`. __Defaults to false__\n* **hashChange** {Boolean} - If you'd like to use pushState, but have browsers that don't support it natively use full page refreshes instead, you can add `{hashChange: false}` to the options. __Defaults to true__\n* **root** {String} - If your application is not being served from the root url `/` of your domain, be sure to tell History where the root really is, as an option: `router.history.start({pushState: true, root: \"/public/search/\"})`. __Defaults to `/`__\n* **silent** {Boolean} - If the server has already rendered the entire page, and you don't want the initial route to trigger when starting History, pass `silent: true`. __Defaults to false__\n\nWhen called, if a route succeeds with a match for the current URL, `router.history.start()` returns `true`. If no defined route matches the current URL, it returns `false`.\n\n\n<!-- starthide -->\n## credits\n\nAll credit goes to Jeremy Ashkenas and the rest of the Backbone.js authors.\n\nIf you like this follow [@HenrikJoreteg](http://twitter.com/henrikjoreteg) on twitter.\n\n## license\n\nMIT\n<!-- endhide -->\n",
  "readmeFilename": "README.md",
  "_id": "ampersand-router@1.0.2",
  "dist": {
    "shasum": "b1146b0845d0663f3623cb6a7bb0025a514dcf5e"
  },
  "_from": "ampersand-router@^1.0.1",
  "_resolved": "https://registry.npmjs.org/ampersand-router/-/ampersand-router-1.0.2.tgz"
}
