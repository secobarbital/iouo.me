{
  "name": "ampersand-view",
  "description": "A smart base view for Backbone apps, to make it easy to bind collections and properties to the DOM.",
  "version": "6.0.10",
  "author": {
    "name": "Henrik Joreteg",
    "email": "henrik@andyet.net"
  },
  "browser": "./ampersand-view.js",
  "bugs": {
    "url": "https://github.com/ampersandjs/ampersand-view/issues"
  },
  "dependencies": {
    "ampersand-collection-view": "^1.0.0",
    "ampersand-dom-bindings": "^2.1.0",
    "ampersand-state": "^4.2.7",
    "component-classes": "^1.0.0",
    "domify": "^1.0.0",
    "events-mixin": "^1.1.0",
    "get-object-path": "^0.0.2",
    "matches-selector": "^1.0.0",
    "underscore": "^1.6.0"
  },
  "devDependencies": {
    "ampersand-model": "~2.10.6",
    "ampersand-rest-collection": "^1.0.3",
    "browserify": "~3.41.0",
    "jsdom": "^0.10.6",
    "precommit-hook": "0.x.x",
    "run-browser": "~1.2.0",
    "tap-spec": "^0.2.0",
    "tape": "~2.12.1",
    "tape-run": "~0.1.1"
  },
  "homepage": "https://github.com/ampersandjs/ampersand-view",
  "keywords": [
    "backbone",
    "view",
    "browser",
    "browserify"
  ],
  "license": "MIT",
  "main": "./ampersand-view.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/ampersandjs/ampersand-view.git"
  },
  "scripts": {
    "validate": "jshint .",
    "start": "run-browser test/index.js",
    "test": "browserify test/index.js | tape-run | tap-spec"
  },
  "testling": {
    "files": "test/*.js",
    "browsers": [
      "ie/9..latest",
      "firefox/17..latest",
      "firefox/nightly",
      "chrome/22..latest",
      "chrome/canary",
      "opera/12..latest",
      "opera/next",
      "safari/5.1..latest",
      "ipad/6.0..latest",
      "iphone/6.0..latest",
      "android-browser/4.2..latest"
    ]
  },
  "readme": "# ampersand-view\n\nA set of common helpers and conventions for using as a base view for ampersand.js apps.\n\nWhat does it do?\n\n1. Gives you a proven pattern for managing/binding the contents of an element.\n2. Simple declarative property/template bindings without needing to include a template engine that does it for you. This keeps your logic out of your templates and lets you use a string of HTML as a fully dynamic template or just a simple function that returns an HTML string.\n3. The view's base element is replaced (or created) during a render. So, rather than having to specify tag type and attributes in javascript in the view definition you can just include that in your template like everything else.\n4. A way to render a collection of models within an element in the view, each with their own view, preserving order, and doing proper cleanup when the main view is removed.\n5. A simple way to render sub-views that get cleaned up when the parent view is removed.\n\n<!-- starthide -->\nPart of the [Ampersand.js toolkit](http://ampersandjs.com) for building clientside applications.\n<!-- endhide -->\n\n<!-- starthide -->\n\n## Browser support\n\n[![browser support](https://ci.testling.com/ampersandjs/ampersand-view.png)\n](https://ci.testling.com/ampersandjs/ampersand-view)\n<!-- endhide -->\n\n## Install\n\n```\nnpm install ampersand-view\n```\n\n## API Reference\n\nNote that this is a fork of Backbone's view so most of the public methods/properties here still exist: [http://backbonejs.org/#View](http://backbonejs.org/#View).\n\n### extend `AmpersandView.extend([properties])`\n\nGet started with views by creating a custom view class. Ampersand views have a sane default render function, which you don't necessarily have to override, but you probably will wish to specify a [`template`](#ampersand-view-template), your declarative [event handlers](#ampersand-view-events) and your [view bindings](#ampersand-view-bindings).\n\n```javascript\nvar PersonRowView = AmpersandView.extend({\n    template: \"<li> <span role='name'></span> <span role='age'></span> <a role='edit'>edit</a> </li>\",\n\n    events: {\n        \"click [role=edit]\": \"edit\"\n    },\n\n    bindings: {\n        \"model.name\": {\n            type: 'text',\n            role: 'name'\n        },\n\n        \"model.age\": {\n            type: 'text',\n            role: 'age'\n        }\n    },\n\n    edit: function () {\n        //...\n    }\n});\n```\n\n\n### template `AmpersandView.extend({ template: \"<div><input></div>\" })`\n\nThe `.template` is a property for the view prototype. It should either be a string of HTML or a function that returns a string of HTML or a DOM element. It isn't required, but it is used as a default for calling `renderWithTemplate`.\n\nThe important thing to note is that __*the returned string/HTML should not have more than one root element*__. This is because the view code assumes that it has one and only one root element that becomes the `.el` property of the instantiated view.\n\nFor more information about creating, and compiling templates, [read the templating guide](http://ampersandjs.com/learn/templates).\n\n### autoRender `AmpersandView.extend({ autoRender: true })`\n\nThe `.autoRender` property lets you optionally specify that the view should just automatically render with all the defaults. This requires that you at minimum specify a [template](#template) string or function.\n\nBy setting `autoRender: true` the view will simply call `.renderWithTemplate` for you (after your `initialize` method if present). So for simple views, if you've got a few bindings and a template your whole view could just be really declarative like this:\n\n```javascript\nvar AmpersandView = require('ampersand-view');\n\n\nmodule.exports = AmpersandView.extend({\n    autoRender: true,\n    template: '<div><span id=\"username\"></span></div>',\n    bindings: {\n        name: '#username'\n    }\n});\n```\n\n**Note:** if you are using a template function (and not a string) the template function will get called with a context argument that looks like this, giving you access to `.model`, `.collection` and any other props you have defined on the view from the template.\n\n```javascript\nthis.renderWithTemplate(this, this.template);\n```\n\n### events `AmpersandView.extend({ events: { /* ...events hash... */ } })`\n\nThe events hash allows you to specify declarative callbacks for DOM events within the view. This is much clearer and less complex than calling `el.addEventListener('click', ...)` everywhere.\n\n* Events are written in the format `{\"event selector\": \"callback\"}`.\n* The callback may either be the name of a method on the view, or an actual function.\n* Omitting the `selector` causes the event to be bound to the view's root element (`this.el`).\n* The events property may also be defined as a function that returns an *events* hash, to make it easier to programmatically define your events, as well as inherit them from parent views.\n\nUsing the events hash has a number of benefits over manually binding events during the `render` call:\n\n* All attached callbacks are bound to the view before being handed off to the event handler, so when the callbacks are invoked, `this` continues to refer to the view object.\n* All event handlers are delegated to the view's root el, meaning elements changed when the view is updated don't need to be unbound and rebound.\n* All events handlers are cleanly remvoed when the view is [removed](#ampersand-view-remove).\n\n```\nvar DocumentView = AmpersandView.extend({\n\n  events: {\n    //bind to a double click on the root element\n    \"dblclick\"                : \"open\",\n\n    //bind to a click on an element with both 'icon' and 'doc' classes\n    \"click .icon.doc\"         : \"select\",\n\n    \"contextmenu .icon.doc\"   : \"showMenu\",\n    \"click .show_notes\"       : \"toggleNotes\",\n    \"click .title .lock\"      : \"editAccessLevel\",\n    \"mouseover .title .date\"  : \"showTooltip\"\n  },\n\n  open: function() {\n    window.open(this.model.viewer_url);\n  },\n\n  select: function() {\n    this.model.selected = true;\n  },\n\n  //...\n\n});\n```\n\n### bindings\n\nThe bindings hash gives you a declarative way of specifying which elements in your view should be updated when the view's model is changed.\n\nFor a full reference of available binding types see the [ampersand-dom-bindings](#ampersand-dom-bindings) section.\n\nFor example, with a model like this:\n\n```javascript\nvar Person = AmpersandModel.extend({\n    props: {\n        name: 'string',\n        age: 'number',\n        avatarURL: 'string'\n    },\n    session: {\n        selected: 'boolean'\n    }\n});\n```\n\nand a template like this:\n\n```html\n<!-- templates.person -->\n<li>\n  <img role=\"avatar\">\n  <span role=\"name\"></span>\n  age: <span role=\"age\"></span>\n</li>\n```\n\nyou might have a binding hash in your view like this:\n\n```javascript\nvar PersonView = AmpersandView.extend({\n    templates: templates.person,\n\n    bindings: {\n        'model.name': {\n            type: 'text',\n            role: 'name'\n        },\n\n        'model.age': '[role=age]', //shorthand of the above\n\n        'model.avatarURL': {\n            type: 'attribute',\n            name: 'src',\n            role: 'avatar'\n        },\n\n        //no selector, selects the root element\n        'model.selected': {\n            type: 'booleanClass',\n            name: 'active' //class to toggle\n        }\n    }\n});\n```\n\n### el `view.el`\n\nAll rendered views have a single DOM node which they manage, which is acessible from the `.el` property on the view. Allowing you to insert it into the DOM from the parent context.\n\n```\nvar view = new PersonView({ model: me });\nview.render();\n\ndocument.querySelector('#viewContainer').appendChild(view.el);\n```\n\n\n### constructor `new AmpersandView([options])`\n\nThe default `AmpersandView` constructor accepts an optional `options` object, and:\n\n* Attaches the following options directly to the instantiated view, overriding the defaults: `model`, `collection`, `el`.\n* Sets up event bindings defined in the `events` hash.\n* Sets up the model bindings defined in the `bindings` hash.\n* Initializes any subviews defined in the `subviews` hash.\n* Calls `initialize` passing it the options hash.\n* Renders the view, if `autoRender` is true and a template is defined.\n\nTypical use-cases for the options hash:\n* To initialize a view with an `el` _already_ in the DOM, pass it as an option: `new AmpersandView({ el: existingElement })`.\n* To perform extra work when initializing a new view, override the `initialize` function in the extend call, rather than modifying the constructor, it's easier.\n\n\n### initialize `new AmpersandView([options])`\n\nCalled by the default view constructor after the view is initialized. Overwrite initialize in your views to perform some extra work when the view is initialized. Initially it's a noop:\n\n```javascript\nvar MyView = AmpersandView.extend({\n    initialize: function (options) {\n        console.log(\"The options are:\", options);\n    }\n});\n\nvar view = new MyView({ foo: 'bar' });\n//=> logs 'The options are: {foo: \"bar\"}'\n```\n\n\n### render `view.render()`\n\nRender is a part of the [Ampersand View conventions](???). You can override the default view method when extending AmpersandView if you wish, but as part of the conventions, calling render should:\n\n* Create a `this.el` property if the view doesn't already have one, and populate it with your view template\n* or if the view already has a `this.el` attribute, render should either populate it with your view template, or create a new element and replace the existing `this.el` if it's in the DOM tree.\n* Not be a problem if it's called more than once.\n\n\nThe default render looks like this:\n\n```javascript\nrender: function () {\n    this.renderWithTemplate(this);\n    return this;\n}\n```\n\n### renderCollection `view.renderCollection(collection, ItemView, containerEl, [viewOptions])`\n\n* `collection` {Backbone Collection} The instantiated collection we wish to render.\n* `ItemView` {View Constructor | Function} The view constructor that will be instantiated for each model in the collection or a function that will return an instance of a given constructor. `options` object is passed as a first argument to a function, which can be used to access `options.model` and determine which view should be instantiated. This view will be used with a reference to the model and collection and the item view's `render` method will be called with an object containing a reference to the containerElement as follows: `.render({containerEl: << element >>})`.\n* `containerEl` {Element} The element that should hold the collection of views.\n* `viewOptions` {Object} [optional] Additional options \n    * `viewOptions` {Object} Options object that will get passed to the `initialize` method of the individual item views.\n    * `filter` {Function} [optional] Function that will be used to determine if a model should be rendered in this collection view. It will get called with a model and you simply return `true` or `false`.\n    * `reverse` {Boolean} [optional] Convenience for reversing order in which the items are rendered.\n\nThis method will maintain this collection within that container element. Including proper handling of add, remove, sort, reset, etc.\n\nAlso, when the parent view gets `.remove()`'ed any event handlers registered by the individual item views will be properly removed as well.\n\nEach item view will only be `.render()`'ed once (unless you change that within the item view itself).\n\n#### Example:\n\n```javascript\n// some views for individual items in the collection\nvar ItemView = AmpersandView.extend({ ... });\nvar AlternativeItemView = AmpersandView.extend({ ... });\n\n// the main view\nvar MainView = AmpersandView.extend({\n    template: '<section class=\"page\"><ul class=\"itemContainer\"></ul></section>',\n    render: function (opts) {\n        // render our template as usual\n        this.renderWithTemplate(this);\n\n        // call renderCollection with these arguments:\n        // 1. collection\n        // 2. which view to use for each item in the list\n        // 3. which element within this view to use as the container\n        // 4. options object (not required):\n        //      {\n        //          // function used to determine if model should be included\n        //          filter: function (model) {},\n        //          // boolean to specify reverse rendering order\n        //          reverse: false,\n        //          // view options object (just gets passed to item view's `initialize` method)\n        //          viewOptions: {}\n        //      }\n        this.renderCollection(this.collection, ItemView, this.el.querySelector('.itemContainer'), opts);\n        return this;\n    }\n});\n\n// alternative main view\nvar AlternativeMainView = AmpersandView.extend({\n    template: '<section class=\"sidebar\"><ul class=\"itemContainer\"></ul></section>',\n    render: function (opts) {\n        this.renderWithTemplate(this);\n        this.renderCollection(this.collection, function (options) {\n            if (options.model.isAlternative) {\n                return new AlternativeMainView(options);\n            }\n\n            return new MainView(options);\n        }, this.el.querySelector('.itemContainer'), opts);\n        return this;\n    }\n});\n```\n\n### renderWithTemplate `view.renderWithTemplate([context], [template])`\n\n* `context` {Object | null} [optional] The context that will be passed to the template function, usually it will be passed the view itself, so that `.model`, `.collection` etc are available.\n* `template` {Function | String} [optional] A function that returns HTML or a string of HTML.\n\nThis is shortcut for the default rendering you're going to do in most every render method, which is: use the template property of the view to replace `this.el` of the view and re-register all handlers from the event hash and any other binding as described above.\n\n```javascript\nvar view = AmpersandView.extend({\n    template: '<li><a></a></li>',\n    bindings: {\n        'name': 'a'\n    },\n    events: {\n        'click a': 'handleLinkClick'\n    },\n    render: function () {\n        // this does everything\n        // 1. renders template\n        // 2. registers delegated click handler\n        // 3. inserts and binds the 'name' property\n        //    of the view's `this.model` to the <a> tag.\n        this.renderWithTemplate();\n    }\n});\n```\n\n### get `view.get('.classname')`\n\nRuns a [`querySelector`](https://developer.mozilla.org/en-US/docs/Web/API/document.querySelector) scoped within the view's current element (`view.el`), returning the first matching element in the dom-tree.\n\n```javascript\nvar view = AmpersandView.extend({\n    template: '<li><img role=\"avatar\" src=\"\"></li>',\n    render: function () {\n        this.renderWithTemplate(this);\n\n        // cache an element for easy reference by other methods\n        this.imgEl = this.get(\"[role=avatar]\");\n\n        return this;\n    }\n});\n```\n\n### getByRole `view.getByRole('rolename')`\n\nA convenience method for retrieving an element from the current view by role. Using the role attribute is a nice way to separate javascript view hooks/bindings from class/id selectors that are being used by css:\n\n```javascript\nvar view = AmpersandView.extend({\n    template: '<li><img class='avatar-rounded' role=\"avatar\" src=\"\"></li>',\n    render: function () {\n        this.renderWithTemplate(this);\n\n        // cache an element for easy reference by other methods\n        this.imgEl = this.getByRole('avatar');\n\n        return this;\n    }\n});\n```\n\n\n### getAll `view.getAll('.classname')`\n\nRuns a [`querySelectorAll`](https://developer.mozilla.org/en-US/docs/Web/API/document.querySelectorAll) scoped within the view's current element (`view.el`), returning all the matching elements in the dom-tree.\n\n\n### cacheElements `view.cacheElements(hash)`\nA shortcut for adding reference to specific elements within your view for access later. This is avoids excessive DOM queries and makes it easier to update your view if your template changes.\n\nIn your `render` method. Use it like so:\n\n```javascript\nrender: function () {\n  this.renderWithTemplate(this);\n\n  this.cacheElements({\n    pages: '#pages',\n    chat: '#teamChat',\n    nav: 'nav#views ul',\n    me: '#me',\n    cheatSheet: '#cheatSheet',\n    omniBox: '[role=omnibox]'\n  });\n\n  return this;\n}\n```\n\nThen later you can access elements by reference like so: `this.pages`, or `this.chat`.\n\n\n### listenToAndRun `view.listenToAndRun(object, eventsString, callback)`\nShortcut for registering a listener for a model and also triggering it right away.\n\n\n### remove `view.remove()`\n\nRemoves a view from the DOM, and calls `stopListening` to remove any bound events that the view has `listenTo`'d.\n\n\n\n### registerSubview `view.registerSubview(viewInstance)`\n\n* viewInstance {Object} Any object with a \"remove\" method, typically an instantiated view. But doesn't have to be, it can be anything with a remove method. The remove method doesn't have to actually remove itself from the DOM (since the parent view is being removed anyway), it is generally just used for unregistering any handler that it set up.\n\n\n### renderSubview `view.renderSubview(viewInstance, containerEl)`\n\n* viewInstance {Object} Any object with a `.remove()`, `.render()` and an `.el` property that is the DOM element for that view. Typically this is just an instantiated view. \n* containerEl {Element | String} This can either be an actual DOM element or a CSS selector string such as `.container`. If a string is passed human view runs `this.get('YOUR STRING')` to try to grab the element that should contain the sub view.\n\nThis method is just sugar for the common use case of instantiating a view and putting in an element within the parent.\n\nIt will:\n\n1. fetch your container (if you gave it a selector string)\n2. register your subview so it gets cleaned up if parent is removed and so `view.parent` will be available when your subview's `render` method gets called\n3. call the subview's `render()` method\n4. append it to the container\n5. return the subview\n\n```javascript\nvar view = AmpersandView.extend({\n    template: '<li><div class=\"container\"></div></li>',\n    render: function () {\n        this.renderWithTemplate();\n\n        //...\n\n        var model = this.model;\n        this.renderSubview(new SubView({\n            model: model\n        }), '.container');\n\n        //...\n\n    }\n});\n```\n\n### subviews `view.subviews`\n\nYou can declare subviews that you want to render within a view, much like you would bindings. Useful for cases where the data you need for a subview may not be available on first render. Also, simplifies cases where you have lots of subviews.\n\nWhen the parent view is removed the `remove` method of all subviews will be called as well. \n\nYou declare them as follows:\n\n```javascript\nvar AmpersandView = require('ampersand-view');\nvar CollectionRenderer = require('ampersand-collection-view');\nvar ViewSwitcher = require('ampersand-view-switcher');\n\n\nmodule.exports = AmpersandView.extend({\n    template: '<div><div></div><ul role=\"collection-container\"></ul></div>',\n    subviews: {\n        myStuff: {\n            container: '[role=collection-container]',\n            waitFor: 'model.stuffCollection',\n            prepareView: function (el) {\n                return new CollectionRenderer({\n                    el: el,\n                    collection: this.model.stuffCollection\n                });\n            }\n        },\n        tab: {\n            container: '[role=switcher]',\n            constructor: ViewSwitcher\n        }\n    }\n});\n```\n\nsubview declarations consist of:\n\n* container {String} Selector that describes the element within the view that should hold the subview.\n* role {String} Alternate method for specifying a container element using its role name. Equivalent to `selector: '[role=some-role]'`.\n* constructor {ViewConstructor} Any [view conventions compliant](http://ampersandjs.com/learn/view-conventions) view constructor. It will be initialized with `{el: [Element grabbed from selector], parent: [reference to parent view instance]}`. So if you don't need to do any custom setup, you can just provide the constructor.\n* waitFor {String} String specifying they \"key-path\" (i.e. 'model.property') of the view that must be \"truthy\" before it should consider the subview ready.\n* prepareView {Function} Function that will be called once any `waitFor` condition is met. It will be called with the `this` context of the parent view and with the element that matches the selector as the argument. It should return an instantiated view instance.\n\n\n### delegateEvents `view.delegateEvents([events])`\n\nCreates delegated DOM event handlers for view elements on `this.el`. If `events` is omitted, will use the `events` property on the view.\n\nGenerally you won't need to call `delegateEvents` yourself, if you define an `event` hash when extending AmpersandView, `delegateEvents` will be called for you when the view is initialize.\n\nEvents is a hash of  `{\"event selector\": \"callback\"}*`\n\nWill unbind existing events by calling `undelegateEvents` before binding new ones when called. Allowing you to switch events for different view contexts, or different views bound to the same element.\n\n```javascript\n{\n  'mousedown .title':  'edit',\n  'click .button':     'save',\n  'click .open':       function (e) { ... }\n}\n```\n\n### undelegateEvents `view.undelegateEvents()`\n\nClears all callbacks previously bound to the view with `delegateEvents`.\nYou usually don't need to use this, but may wish to if you have multiple views attached to the same DOM element.\n\n\n## Changelog\n\n- 1.6.3 [diff](https://github.com/HenrikJoreteg/ampersand-view/compare/v1.6.2...v1.6.3) - Move throw statment for too many root elements inside non `<body>` case.\n- 1.6.2 [diff](https://github.com/HenrikJoreteg/ampersand-view/compare/v1.6.1...v1.6.2) - Make `getByRole` work even if `role` attribute is on the root element. Throws an error if your view template contains more than one root element.\n- 1.6.1 [diff](https://github.com/HenrikJoreteg/ampersand-view/compare/v1.6.0...v1.6.1) - Make sure renderSubview registers the subview first, so it has a `.parent` before it calls `.render()` on the subview.\n- 1.6.0 [diff](https://github.com/HenrikJoreteg/ampersand-view/compare/v1.5.0...v1.6.0) - Adding `getByRole` method\n- 1.5.0 - Adding bower.json, adding missing dev dependencies, other small bugfixes.\n- 1.4.1 - Removing elements without using jQuery's `.empty()` in renderCollection. (fixes: https://github.com/HenrikJoreteg/ampersand-view/issues/13)\n- 1.4.0 - Adding `parent` reference to subviews registered via registerSubview\n\n<!---starthide-->\n\n## Test coverage?\n\nWhy yes! So glad you asked :)  \n\nOpen `test/test.html` in a browser to run the QUnit tests.\n\n## Like this?\n\nFollow [@HenrikJoreteg](http://twitter.com/henrikjoreteg) on twitter and check out my recently released book: [human javascript](http://humanjavascript.com) which includes a full explanation of this as well as a whole bunch of other stuff for building awesome single page apps. \n\n## license\n\nMIT\n\n<!---endhide-->\n",
  "readmeFilename": "README.md",
  "_id": "ampersand-view@6.0.10",
  "dist": {
    "shasum": "8a32a65ad8db4e067e24cc80422a7e8e9e8c2508"
  },
  "_from": "ampersand-view@^6.0.3",
  "_resolved": "https://registry.npmjs.org/ampersand-view/-/ampersand-view-6.0.10.tgz"
}
